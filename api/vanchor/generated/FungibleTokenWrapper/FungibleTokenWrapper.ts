// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import { ethereum, JSONValue, TypedMap, Entity, Bytes, Address, BigInt } from '@graphprotocol/graph-ts';

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class HandlerUpdated extends ethereum.Event {
  get params(): HandlerUpdated__Params {
    return new HandlerUpdated__Params(this);
  }
}

export class HandlerUpdated__Params {
  _event: HandlerUpdated;

  constructor(event: HandlerUpdated) {
    this._event = event;
  }

  get _handler(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class Paused extends ethereum.Event {
  get params(): Paused__Params {
    return new Paused__Params(this);
  }
}

export class Paused__Params {
  _event: Paused;

  constructor(event: Paused) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class RoleAdminChanged extends ethereum.Event {
  get params(): RoleAdminChanged__Params {
    return new RoleAdminChanged__Params(this);
  }
}

export class RoleAdminChanged__Params {
  _event: RoleAdminChanged;

  constructor(event: RoleAdminChanged) {
    this._event = event;
  }

  get role(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get previousAdminRole(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get newAdminRole(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class RoleGranted extends ethereum.Event {
  get params(): RoleGranted__Params {
    return new RoleGranted__Params(this);
  }
}

export class RoleGranted__Params {
  _event: RoleGranted;

  constructor(event: RoleGranted) {
    this._event = event;
  }

  get role(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get account(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get sender(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class RoleRevoked extends ethereum.Event {
  get params(): RoleRevoked__Params {
    return new RoleRevoked__Params(this);
  }
}

export class RoleRevoked__Params {
  _event: RoleRevoked;

  constructor(event: RoleRevoked) {
    this._event = event;
  }

  get role(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get account(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get sender(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Unpaused extends ethereum.Event {
  get params(): Unpaused__Params {
    return new Unpaused__Params(this);
  }
}

export class Unpaused__Params {
  _event: Unpaused;

  constructor(event: Unpaused) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class FungibleTokenWrapper extends ethereum.SmartContract {
  static bind(address: Address): FungibleTokenWrapper {
    return new FungibleTokenWrapper('FungibleTokenWrapper', address);
  }

  DEFAULT_ADMIN_ROLE(): Bytes {
    let result = super.call('DEFAULT_ADMIN_ROLE', 'DEFAULT_ADMIN_ROLE():(bytes32)', []);

    return result[0].toBytes();
  }

  try_DEFAULT_ADMIN_ROLE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall('DEFAULT_ADMIN_ROLE', 'DEFAULT_ADMIN_ROLE():(bytes32)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  MINTER_ROLE(): Bytes {
    let result = super.call('MINTER_ROLE', 'MINTER_ROLE():(bytes32)', []);

    return result[0].toBytes();
  }

  try_MINTER_ROLE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall('MINTER_ROLE', 'MINTER_ROLE():(bytes32)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  PAUSER_ROLE(): Bytes {
    let result = super.call('PAUSER_ROLE', 'PAUSER_ROLE():(bytes32)', []);

    return result[0].toBytes();
  }

  try_PAUSER_ROLE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall('PAUSER_ROLE', 'PAUSER_ROLE():(bytes32)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  allowance(owner: Address, spender: Address): BigInt {
    let result = super.call('allowance', 'allowance(address,address):(uint256)', [
      ethereum.Value.fromAddress(owner),
      ethereum.Value.fromAddress(spender),
    ]);

    return result[0].toBigInt();
  }

  try_allowance(owner: Address, spender: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall('allowance', 'allowance(address,address):(uint256)', [
      ethereum.Value.fromAddress(owner),
      ethereum.Value.fromAddress(spender),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  approve(spender: Address, amount: BigInt): boolean {
    let result = super.call('approve', 'approve(address,uint256):(bool)', [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);

    return result[0].toBoolean();
  }

  try_approve(spender: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('approve', 'approve(address,uint256):(bool)', [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  balanceOf(account: Address): BigInt {
    let result = super.call('balanceOf', 'balanceOf(address):(uint256)', [ethereum.Value.fromAddress(account)]);

    return result[0].toBigInt();
  }

  try_balanceOf(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall('balanceOf', 'balanceOf(address):(uint256)', [ethereum.Value.fromAddress(account)]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  decimals(): i32 {
    let result = super.call('decimals', 'decimals():(uint8)', []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall('decimals', 'decimals():(uint8)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  decreaseAllowance(spender: Address, subtractedValue: BigInt): boolean {
    let result = super.call('decreaseAllowance', 'decreaseAllowance(address,uint256):(bool)', [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(subtractedValue),
    ]);

    return result[0].toBoolean();
  }

  try_decreaseAllowance(spender: Address, subtractedValue: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('decreaseAllowance', 'decreaseAllowance(address,uint256):(bool)', [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(subtractedValue),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  feePercentage(): i32 {
    let result = super.call('feePercentage', 'feePercentage():(uint16)', []);

    return result[0].toI32();
  }

  try_feePercentage(): ethereum.CallResult<i32> {
    let result = super.tryCall('feePercentage', 'feePercentage():(uint16)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  feeRecipient(): Address {
    let result = super.call('feeRecipient', 'feeRecipient():(address)', []);

    return result[0].toAddress();
  }

  try_feeRecipient(): ethereum.CallResult<Address> {
    let result = super.tryCall('feeRecipient', 'feeRecipient():(address)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getAmountToWrap(_deposit: BigInt): BigInt {
    let result = super.call('getAmountToWrap', 'getAmountToWrap(uint256):(uint256)', [
      ethereum.Value.fromUnsignedBigInt(_deposit),
    ]);

    return result[0].toBigInt();
  }

  try_getAmountToWrap(_deposit: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall('getAmountToWrap', 'getAmountToWrap(uint256):(uint256)', [
      ethereum.Value.fromUnsignedBigInt(_deposit),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getFee(): i32 {
    let result = super.call('getFee', 'getFee():(uint16)', []);

    return result[0].toI32();
  }

  try_getFee(): ethereum.CallResult<i32> {
    let result = super.tryCall('getFee', 'getFee():(uint16)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  getFeeFromAmount(_amountToWrap: BigInt): BigInt {
    let result = super.call('getFeeFromAmount', 'getFeeFromAmount(uint256):(uint256)', [
      ethereum.Value.fromUnsignedBigInt(_amountToWrap),
    ]);

    return result[0].toBigInt();
  }

  try_getFeeFromAmount(_amountToWrap: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall('getFeeFromAmount', 'getFeeFromAmount(uint256):(uint256)', [
      ethereum.Value.fromUnsignedBigInt(_amountToWrap),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getProposalNonce(): BigInt {
    let result = super.call('getProposalNonce', 'getProposalNonce():(uint256)', []);

    return result[0].toBigInt();
  }

  try_getProposalNonce(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('getProposalNonce', 'getProposalNonce():(uint256)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getRoleAdmin(role: Bytes): Bytes {
    let result = super.call('getRoleAdmin', 'getRoleAdmin(bytes32):(bytes32)', [ethereum.Value.fromFixedBytes(role)]);

    return result[0].toBytes();
  }

  try_getRoleAdmin(role: Bytes): ethereum.CallResult<Bytes> {
    let result = super.tryCall('getRoleAdmin', 'getRoleAdmin(bytes32):(bytes32)', [
      ethereum.Value.fromFixedBytes(role),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getRoleMember(role: Bytes, index: BigInt): Address {
    let result = super.call('getRoleMember', 'getRoleMember(bytes32,uint256):(address)', [
      ethereum.Value.fromFixedBytes(role),
      ethereum.Value.fromUnsignedBigInt(index),
    ]);

    return result[0].toAddress();
  }

  try_getRoleMember(role: Bytes, index: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall('getRoleMember', 'getRoleMember(bytes32,uint256):(address)', [
      ethereum.Value.fromFixedBytes(role),
      ethereum.Value.fromUnsignedBigInt(index),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getRoleMemberCount(role: Bytes): BigInt {
    let result = super.call('getRoleMemberCount', 'getRoleMemberCount(bytes32):(uint256)', [
      ethereum.Value.fromFixedBytes(role),
    ]);

    return result[0].toBigInt();
  }

  try_getRoleMemberCount(role: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall('getRoleMemberCount', 'getRoleMemberCount(bytes32):(uint256)', [
      ethereum.Value.fromFixedBytes(role),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTokens(): Array<Address> {
    let result = super.call('getTokens', 'getTokens():(address[])', []);

    return result[0].toAddressArray();
  }

  try_getTokens(): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall('getTokens', 'getTokens():(address[])', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  handler(): Address {
    let result = super.call('handler', 'handler():(address)', []);

    return result[0].toAddress();
  }

  try_handler(): ethereum.CallResult<Address> {
    let result = super.tryCall('handler', 'handler():(address)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  hasRole(role: Bytes, account: Address): boolean {
    let result = super.call('hasRole', 'hasRole(bytes32,address):(bool)', [
      ethereum.Value.fromFixedBytes(role),
      ethereum.Value.fromAddress(account),
    ]);

    return result[0].toBoolean();
  }

  try_hasRole(role: Bytes, account: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall('hasRole', 'hasRole(bytes32,address):(bool)', [
      ethereum.Value.fromFixedBytes(role),
      ethereum.Value.fromAddress(account),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  historicalTokens(param0: BigInt): Address {
    let result = super.call('historicalTokens', 'historicalTokens(uint256):(address)', [
      ethereum.Value.fromUnsignedBigInt(param0),
    ]);

    return result[0].toAddress();
  }

  try_historicalTokens(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall('historicalTokens', 'historicalTokens(uint256):(address)', [
      ethereum.Value.fromUnsignedBigInt(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  historicallyValid(param0: Address): boolean {
    let result = super.call('historicallyValid', 'historicallyValid(address):(bool)', [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBoolean();
  }

  try_historicallyValid(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall('historicallyValid', 'historicallyValid(address):(bool)', [
      ethereum.Value.fromAddress(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  increaseAllowance(spender: Address, addedValue: BigInt): boolean {
    let result = super.call('increaseAllowance', 'increaseAllowance(address,uint256):(bool)', [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(addedValue),
    ]);

    return result[0].toBoolean();
  }

  try_increaseAllowance(spender: Address, addedValue: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('increaseAllowance', 'increaseAllowance(address,uint256):(bool)', [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(addedValue),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  initialized(): boolean {
    let result = super.call('initialized', 'initialized():(bool)', []);

    return result[0].toBoolean();
  }

  try_initialized(): ethereum.CallResult<boolean> {
    let result = super.tryCall('initialized', 'initialized():(bool)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isNativeAllowed(): boolean {
    let result = super.call('isNativeAllowed', 'isNativeAllowed():(bool)', []);

    return result[0].toBoolean();
  }

  try_isNativeAllowed(): ethereum.CallResult<boolean> {
    let result = super.tryCall('isNativeAllowed', 'isNativeAllowed():(bool)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isValidToken(tokenAddress: Address): boolean {
    let result = super.call('isValidToken', 'isValidToken(address):(bool)', [ethereum.Value.fromAddress(tokenAddress)]);

    return result[0].toBoolean();
  }

  try_isValidToken(tokenAddress: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall('isValidToken', 'isValidToken(address):(bool)', [
      ethereum.Value.fromAddress(tokenAddress),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  name(): string {
    let result = super.call('name', 'name():(string)', []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall('name', 'name():(string)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  paused(): boolean {
    let result = super.call('paused', 'paused():(bool)', []);

    return result[0].toBoolean();
  }

  try_paused(): ethereum.CallResult<boolean> {
    let result = super.tryCall('paused', 'paused():(bool)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  proposalNonce(): BigInt {
    let result = super.call('proposalNonce', 'proposalNonce():(uint256)', []);

    return result[0].toBigInt();
  }

  try_proposalNonce(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('proposalNonce', 'proposalNonce():(uint256)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  supportsInterface(interfaceId: Bytes): boolean {
    let result = super.call('supportsInterface', 'supportsInterface(bytes4):(bool)', [
      ethereum.Value.fromFixedBytes(interfaceId),
    ]);

    return result[0].toBoolean();
  }

  try_supportsInterface(interfaceId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall('supportsInterface', 'supportsInterface(bytes4):(bool)', [
      ethereum.Value.fromFixedBytes(interfaceId),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  symbol(): string {
    let result = super.call('symbol', 'symbol():(string)', []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall('symbol', 'symbol():(string)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  tokens(param0: BigInt): Address {
    let result = super.call('tokens', 'tokens(uint256):(address)', [ethereum.Value.fromUnsignedBigInt(param0)]);

    return result[0].toAddress();
  }

  try_tokens(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall('tokens', 'tokens(uint256):(address)', [ethereum.Value.fromUnsignedBigInt(param0)]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  totalSupply(): BigInt {
    let result = super.call('totalSupply', 'totalSupply():(uint256)', []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('totalSupply', 'totalSupply():(uint256)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  transfer(to: Address, amount: BigInt): boolean {
    let result = super.call('transfer', 'transfer(address,uint256):(bool)', [
      ethereum.Value.fromAddress(to),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);

    return result[0].toBoolean();
  }

  try_transfer(to: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('transfer', 'transfer(address,uint256):(bool)', [
      ethereum.Value.fromAddress(to),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFrom(from: Address, to: Address, amount: BigInt): boolean {
    let result = super.call('transferFrom', 'transferFrom(address,address,uint256):(bool)', [
      ethereum.Value.fromAddress(from),
      ethereum.Value.fromAddress(to),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);

    return result[0].toBoolean();
  }

  try_transferFrom(from: Address, to: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('transferFrom', 'transferFrom(address,address,uint256):(bool)', [
      ethereum.Value.fromAddress(from),
      ethereum.Value.fromAddress(to),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  valid(param0: Address): boolean {
    let result = super.call('valid', 'valid(address):(bool)', [ethereum.Value.fromAddress(param0)]);

    return result[0].toBoolean();
  }

  try_valid(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall('valid', 'valid(address):(bool)', [ethereum.Value.fromAddress(param0)]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  wrappingLimit(): BigInt {
    let result = super.call('wrappingLimit', 'wrappingLimit():(uint256)', []);

    return result[0].toBigInt();
  }

  try_wrappingLimit(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('wrappingLimit', 'wrappingLimit():(uint256)', []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _name(): string {
    return this._call.inputValues[0].value.toString();
  }

  get _symbol(): string {
    return this._call.inputValues[1].value.toString();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AddCall extends ethereum.Call {
  get inputs(): AddCall__Inputs {
    return new AddCall__Inputs(this);
  }

  get outputs(): AddCall__Outputs {
    return new AddCall__Outputs(this);
  }
}

export class AddCall__Inputs {
  _call: AddCall;

  constructor(call: AddCall) {
    this._call = call;
  }

  get _tokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _nonce(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class AddCall__Outputs {
  _call: AddCall;

  constructor(call: AddCall) {
    this._call = call;
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class BurnCall extends ethereum.Call {
  get inputs(): BurnCall__Inputs {
    return new BurnCall__Inputs(this);
  }

  get outputs(): BurnCall__Outputs {
    return new BurnCall__Outputs(this);
  }
}

export class BurnCall__Inputs {
  _call: BurnCall;

  constructor(call: BurnCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class BurnCall__Outputs {
  _call: BurnCall;

  constructor(call: BurnCall) {
    this._call = call;
  }
}

export class BurnFromCall extends ethereum.Call {
  get inputs(): BurnFromCall__Inputs {
    return new BurnFromCall__Inputs(this);
  }

  get outputs(): BurnFromCall__Outputs {
    return new BurnFromCall__Outputs(this);
  }
}

export class BurnFromCall__Inputs {
  _call: BurnFromCall;

  constructor(call: BurnFromCall) {
    this._call = call;
  }

  get account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class BurnFromCall__Outputs {
  _call: BurnFromCall;

  constructor(call: BurnFromCall) {
    this._call = call;
  }
}

export class DecreaseAllowanceCall extends ethereum.Call {
  get inputs(): DecreaseAllowanceCall__Inputs {
    return new DecreaseAllowanceCall__Inputs(this);
  }

  get outputs(): DecreaseAllowanceCall__Outputs {
    return new DecreaseAllowanceCall__Outputs(this);
  }
}

export class DecreaseAllowanceCall__Inputs {
  _call: DecreaseAllowanceCall;

  constructor(call: DecreaseAllowanceCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get subtractedValue(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class DecreaseAllowanceCall__Outputs {
  _call: DecreaseAllowanceCall;

  constructor(call: DecreaseAllowanceCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class GrantRoleCall extends ethereum.Call {
  get inputs(): GrantRoleCall__Inputs {
    return new GrantRoleCall__Inputs(this);
  }

  get outputs(): GrantRoleCall__Outputs {
    return new GrantRoleCall__Outputs(this);
  }
}

export class GrantRoleCall__Inputs {
  _call: GrantRoleCall;

  constructor(call: GrantRoleCall) {
    this._call = call;
  }

  get role(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get account(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class GrantRoleCall__Outputs {
  _call: GrantRoleCall;

  constructor(call: GrantRoleCall) {
    this._call = call;
  }
}

export class IncreaseAllowanceCall extends ethereum.Call {
  get inputs(): IncreaseAllowanceCall__Inputs {
    return new IncreaseAllowanceCall__Inputs(this);
  }

  get outputs(): IncreaseAllowanceCall__Outputs {
    return new IncreaseAllowanceCall__Outputs(this);
  }
}

export class IncreaseAllowanceCall__Inputs {
  _call: IncreaseAllowanceCall;

  constructor(call: IncreaseAllowanceCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get addedValue(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class IncreaseAllowanceCall__Outputs {
  _call: IncreaseAllowanceCall;

  constructor(call: IncreaseAllowanceCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get _feePercentage(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get _feeRecipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _handler(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _limit(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _isNativeAllowed(): boolean {
    return this._call.inputValues[4].value.toBoolean();
  }

  get _admin(): Address {
    return this._call.inputValues[5].value.toAddress();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class MintCall extends ethereum.Call {
  get inputs(): MintCall__Inputs {
    return new MintCall__Inputs(this);
  }

  get outputs(): MintCall__Outputs {
    return new MintCall__Outputs(this);
  }
}

export class MintCall__Inputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class MintCall__Outputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }
}

export class PauseCall extends ethereum.Call {
  get inputs(): PauseCall__Inputs {
    return new PauseCall__Inputs(this);
  }

  get outputs(): PauseCall__Outputs {
    return new PauseCall__Outputs(this);
  }
}

export class PauseCall__Inputs {
  _call: PauseCall;

  constructor(call: PauseCall) {
    this._call = call;
  }
}

export class PauseCall__Outputs {
  _call: PauseCall;

  constructor(call: PauseCall) {
    this._call = call;
  }
}

export class RemoveCall extends ethereum.Call {
  get inputs(): RemoveCall__Inputs {
    return new RemoveCall__Inputs(this);
  }

  get outputs(): RemoveCall__Outputs {
    return new RemoveCall__Outputs(this);
  }
}

export class RemoveCall__Inputs {
  _call: RemoveCall;

  constructor(call: RemoveCall) {
    this._call = call;
  }

  get _tokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _nonce(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RemoveCall__Outputs {
  _call: RemoveCall;

  constructor(call: RemoveCall) {
    this._call = call;
  }
}

export class RenounceRoleCall extends ethereum.Call {
  get inputs(): RenounceRoleCall__Inputs {
    return new RenounceRoleCall__Inputs(this);
  }

  get outputs(): RenounceRoleCall__Outputs {
    return new RenounceRoleCall__Outputs(this);
  }
}

export class RenounceRoleCall__Inputs {
  _call: RenounceRoleCall;

  constructor(call: RenounceRoleCall) {
    this._call = call;
  }

  get role(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get account(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class RenounceRoleCall__Outputs {
  _call: RenounceRoleCall;

  constructor(call: RenounceRoleCall) {
    this._call = call;
  }
}

export class RevokeRoleCall extends ethereum.Call {
  get inputs(): RevokeRoleCall__Inputs {
    return new RevokeRoleCall__Inputs(this);
  }

  get outputs(): RevokeRoleCall__Outputs {
    return new RevokeRoleCall__Outputs(this);
  }
}

export class RevokeRoleCall__Inputs {
  _call: RevokeRoleCall;

  constructor(call: RevokeRoleCall) {
    this._call = call;
  }

  get role(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get account(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class RevokeRoleCall__Outputs {
  _call: RevokeRoleCall;

  constructor(call: RevokeRoleCall) {
    this._call = call;
  }
}

export class SetFeeCall extends ethereum.Call {
  get inputs(): SetFeeCall__Inputs {
    return new SetFeeCall__Inputs(this);
  }

  get outputs(): SetFeeCall__Outputs {
    return new SetFeeCall__Outputs(this);
  }
}

export class SetFeeCall__Inputs {
  _call: SetFeeCall;

  constructor(call: SetFeeCall) {
    this._call = call;
  }

  get _feePercentage(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get _nonce(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetFeeCall__Outputs {
  _call: SetFeeCall;

  constructor(call: SetFeeCall) {
    this._call = call;
  }
}

export class SetFeeRecipientCall extends ethereum.Call {
  get inputs(): SetFeeRecipientCall__Inputs {
    return new SetFeeRecipientCall__Inputs(this);
  }

  get outputs(): SetFeeRecipientCall__Outputs {
    return new SetFeeRecipientCall__Outputs(this);
  }
}

export class SetFeeRecipientCall__Inputs {
  _call: SetFeeRecipientCall;

  constructor(call: SetFeeRecipientCall) {
    this._call = call;
  }

  get _feeRecipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _nonce(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetFeeRecipientCall__Outputs {
  _call: SetFeeRecipientCall;

  constructor(call: SetFeeRecipientCall) {
    this._call = call;
  }
}

export class SetHandlerCall extends ethereum.Call {
  get inputs(): SetHandlerCall__Inputs {
    return new SetHandlerCall__Inputs(this);
  }

  get outputs(): SetHandlerCall__Outputs {
    return new SetHandlerCall__Outputs(this);
  }
}

export class SetHandlerCall__Inputs {
  _call: SetHandlerCall;

  constructor(call: SetHandlerCall) {
    this._call = call;
  }

  get _handler(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetHandlerCall__Outputs {
  _call: SetHandlerCall;

  constructor(call: SetHandlerCall) {
    this._call = call;
  }
}

export class SetNativeAllowedCall extends ethereum.Call {
  get inputs(): SetNativeAllowedCall__Inputs {
    return new SetNativeAllowedCall__Inputs(this);
  }

  get outputs(): SetNativeAllowedCall__Outputs {
    return new SetNativeAllowedCall__Outputs(this);
  }
}

export class SetNativeAllowedCall__Inputs {
  _call: SetNativeAllowedCall;

  constructor(call: SetNativeAllowedCall) {
    this._call = call;
  }

  get _isNativeAllowed(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetNativeAllowedCall__Outputs {
  _call: SetNativeAllowedCall;

  constructor(call: SetNativeAllowedCall) {
    this._call = call;
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class UnpauseCall extends ethereum.Call {
  get inputs(): UnpauseCall__Inputs {
    return new UnpauseCall__Inputs(this);
  }

  get outputs(): UnpauseCall__Outputs {
    return new UnpauseCall__Outputs(this);
  }
}

export class UnpauseCall__Inputs {
  _call: UnpauseCall;

  constructor(call: UnpauseCall) {
    this._call = call;
  }
}

export class UnpauseCall__Outputs {
  _call: UnpauseCall;

  constructor(call: UnpauseCall) {
    this._call = call;
  }
}

export class UnwrapCall extends ethereum.Call {
  get inputs(): UnwrapCall__Inputs {
    return new UnwrapCall__Inputs(this);
  }

  get outputs(): UnwrapCall__Outputs {
    return new UnwrapCall__Outputs(this);
  }
}

export class UnwrapCall__Inputs {
  _call: UnwrapCall;

  constructor(call: UnwrapCall) {
    this._call = call;
  }

  get tokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class UnwrapCall__Outputs {
  _call: UnwrapCall;

  constructor(call: UnwrapCall) {
    this._call = call;
  }
}

export class UnwrapAndSendToCall extends ethereum.Call {
  get inputs(): UnwrapAndSendToCall__Inputs {
    return new UnwrapAndSendToCall__Inputs(this);
  }

  get outputs(): UnwrapAndSendToCall__Outputs {
    return new UnwrapAndSendToCall__Outputs(this);
  }
}

export class UnwrapAndSendToCall__Inputs {
  _call: UnwrapAndSendToCall;

  constructor(call: UnwrapAndSendToCall) {
    this._call = call;
  }

  get tokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class UnwrapAndSendToCall__Outputs {
  _call: UnwrapAndSendToCall;

  constructor(call: UnwrapAndSendToCall) {
    this._call = call;
  }
}

export class UnwrapForCall extends ethereum.Call {
  get inputs(): UnwrapForCall__Inputs {
    return new UnwrapForCall__Inputs(this);
  }

  get outputs(): UnwrapForCall__Outputs {
    return new UnwrapForCall__Outputs(this);
  }
}

export class UnwrapForCall__Inputs {
  _call: UnwrapForCall;

  constructor(call: UnwrapForCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class UnwrapForCall__Outputs {
  _call: UnwrapForCall;

  constructor(call: UnwrapForCall) {
    this._call = call;
  }
}

export class UpdateLimitCall extends ethereum.Call {
  get inputs(): UpdateLimitCall__Inputs {
    return new UpdateLimitCall__Inputs(this);
  }

  get outputs(): UpdateLimitCall__Outputs {
    return new UpdateLimitCall__Outputs(this);
  }
}

export class UpdateLimitCall__Inputs {
  _call: UpdateLimitCall;

  constructor(call: UpdateLimitCall) {
    this._call = call;
  }

  get _limit(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class UpdateLimitCall__Outputs {
  _call: UpdateLimitCall;

  constructor(call: UpdateLimitCall) {
    this._call = call;
  }
}

export class WrapCall extends ethereum.Call {
  get inputs(): WrapCall__Inputs {
    return new WrapCall__Inputs(this);
  }

  get outputs(): WrapCall__Outputs {
    return new WrapCall__Outputs(this);
  }
}

export class WrapCall__Inputs {
  _call: WrapCall;

  constructor(call: WrapCall) {
    this._call = call;
  }

  get tokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class WrapCall__Outputs {
  _call: WrapCall;

  constructor(call: WrapCall) {
    this._call = call;
  }
}

export class WrapForCall extends ethereum.Call {
  get inputs(): WrapForCall__Inputs {
    return new WrapForCall__Inputs(this);
  }

  get outputs(): WrapForCall__Outputs {
    return new WrapForCall__Outputs(this);
  }
}

export class WrapForCall__Inputs {
  _call: WrapForCall;

  constructor(call: WrapForCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class WrapForCall__Outputs {
  _call: WrapForCall;

  constructor(call: WrapForCall) {
    this._call = call;
  }
}

export class WrapForAndSendToCall extends ethereum.Call {
  get inputs(): WrapForAndSendToCall__Inputs {
    return new WrapForAndSendToCall__Inputs(this);
  }

  get outputs(): WrapForAndSendToCall__Outputs {
    return new WrapForAndSendToCall__Outputs(this);
  }
}

export class WrapForAndSendToCall__Inputs {
  _call: WrapForAndSendToCall;

  constructor(call: WrapForAndSendToCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get recipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class WrapForAndSendToCall__Outputs {
  _call: WrapForAndSendToCall;

  constructor(call: WrapForAndSendToCall) {
    this._call = call;
  }
}
