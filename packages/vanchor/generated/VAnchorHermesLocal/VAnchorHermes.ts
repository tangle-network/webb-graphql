// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class EdgeAddition extends ethereum.Event {
  get params(): EdgeAddition__Params {
    return new EdgeAddition__Params(this);
  }
}

export class EdgeAddition__Params {
  _event: EdgeAddition;

  constructor(event: EdgeAddition) {
    this._event = event;
  }

  get chainID(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get latestLeafIndex(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get merkleRoot(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class EdgeUpdate extends ethereum.Event {
  get params(): EdgeUpdate__Params {
    return new EdgeUpdate__Params(this);
  }
}

export class EdgeUpdate__Params {
  _event: EdgeUpdate;

  constructor(event: EdgeUpdate) {
    this._event = event;
  }

  get chainID(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get latestLeafIndex(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get merkleRoot(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Insertion extends ethereum.Event {
  get params(): Insertion__Params {
    return new Insertion__Params(this);
  }
}

export class Insertion__Params {
  _event: Insertion;

  constructor(event: Insertion) {
    this._event = event;
  }

  get commitment(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get leafIndex(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get timestamp(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get newMerkleRoot(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class NewCommitment extends ethereum.Event {
  get params(): NewCommitment__Params {
    return new NewCommitment__Params(this);
  }
}

export class NewCommitment__Params {
  _event: NewCommitment;

  constructor(event: NewCommitment) {
    this._event = event;
  }

  get commitment(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get subTreeIndex(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get leafIndex(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get encryptedOutput(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }
}

export class NewNullifier extends ethereum.Event {
  get params(): NewNullifier__Params {
    return new NewNullifier__Params(this);
  }
}

export class NewNullifier__Params {
  _event: NewNullifier;

  constructor(event: NewNullifier) {
    this._event = event;
  }

  get nullifier(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class PublicKey extends ethereum.Event {
  get params(): PublicKey__Params {
    return new PublicKey__Params(this);
  }
}

export class PublicKey__Params {
  _event: PublicKey;

  constructor(event: PublicKey) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get key(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class VAnchorHermes___genExtDataHashInput_externalDataStruct extends ethereum.Tuple {
  get recipient(): Address {
    return this[0].toAddress();
  }

  get extAmount(): BigInt {
    return this[1].toBigInt();
  }

  get relayer(): Address {
    return this[2].toAddress();
  }

  get fee(): BigInt {
    return this[3].toBigInt();
  }

  get refund(): BigInt {
    return this[4].toBigInt();
  }

  get token(): Address {
    return this[5].toAddress();
  }
}

export class VAnchorHermes___genExtDataHashInput_encryptionsStruct extends ethereum.Tuple {
  get encryptedOutput1(): Bytes {
    return this[0].toBytes();
  }

  get encryptedOutput2(): Bytes {
    return this[1].toBytes();
  }
}

export class VAnchorHermes__edgeListResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: Bytes;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt, value3: Bytes) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromFixedBytes(this.value3));
    return map;
  }

  getChainID(): BigInt {
    return this.value0;
  }

  getRoot(): BigInt {
    return this.value1;
  }

  getLatestLeafIndex(): BigInt {
    return this.value2;
  }

  getSrcResourceID(): Bytes {
    return this.value3;
  }
}

export class VAnchorHermes__getLatestNeighborEdgesResultValue0Struct extends ethereum.Tuple {
  get chainID(): BigInt {
    return this[0].toBigInt();
  }

  get root(): BigInt {
    return this[1].toBigInt();
  }

  get latestLeafIndex(): BigInt {
    return this[2].toBigInt();
  }

  get srcResourceID(): Bytes {
    return this[3].toBytes();
  }
}

export class VAnchorHermes__rootsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getRoot(): BigInt {
    return this.value0;
  }

  getLatestLeafindex(): BigInt {
    return this.value1;
  }
}

export class VAnchorHermes__unpackProofResult {
  value0: Array<BigInt>;
  value1: Array<Array<BigInt>>;
  value2: Array<BigInt>;

  constructor(
    value0: Array<BigInt>,
    value1: Array<Array<BigInt>>,
    value2: Array<BigInt>
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigIntArray(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigIntMatrix(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigIntArray(this.value2));
    return map;
  }

  getValue0(): Array<BigInt> {
    return this.value0;
  }

  getValue1(): Array<Array<BigInt>> {
    return this.value1;
  }

  getValue2(): Array<BigInt> {
    return this.value2;
  }
}

export class VAnchorHermes extends ethereum.SmartContract {
  static bind(address: Address): VAnchorHermes {
    return new VAnchorHermes("VAnchorHermes", address);
  }

  EVM_CHAIN_ID_TYPE(): Bytes {
    let result = super.call(
      "EVM_CHAIN_ID_TYPE",
      "EVM_CHAIN_ID_TYPE():(bytes2)",
      []
    );

    return result[0].toBytes();
  }

  try_EVM_CHAIN_ID_TYPE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "EVM_CHAIN_ID_TYPE",
      "EVM_CHAIN_ID_TYPE():(bytes2)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  FIELD_SIZE(): BigInt {
    let result = super.call("FIELD_SIZE", "FIELD_SIZE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_FIELD_SIZE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("FIELD_SIZE", "FIELD_SIZE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  MAX_EXT_AMOUNT(): BigInt {
    let result = super.call("MAX_EXT_AMOUNT", "MAX_EXT_AMOUNT():(int256)", []);

    return result[0].toBigInt();
  }

  try_MAX_EXT_AMOUNT(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "MAX_EXT_AMOUNT",
      "MAX_EXT_AMOUNT():(int256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  MAX_FEE(): BigInt {
    let result = super.call("MAX_FEE", "MAX_FEE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_MAX_FEE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("MAX_FEE", "MAX_FEE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  ROOT_HISTORY_SIZE(): BigInt {
    let result = super.call(
      "ROOT_HISTORY_SIZE",
      "ROOT_HISTORY_SIZE():(uint32)",
      []
    );

    return result[0].toBigInt();
  }

  try_ROOT_HISTORY_SIZE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "ROOT_HISTORY_SIZE",
      "ROOT_HISTORY_SIZE():(uint32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  ZERO_VALUE(): BigInt {
    let result = super.call("ZERO_VALUE", "ZERO_VALUE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_ZERO_VALUE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("ZERO_VALUE", "ZERO_VALUE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  _genExtDataHash(
    param0: Bytes,
    _externalData: VAnchorHermes___genExtDataHashInput_externalDataStruct,
    _encryptions: VAnchorHermes___genExtDataHashInput_encryptionsStruct
  ): Bytes {
    let result = super.call(
      "_genExtDataHash",
      "_genExtDataHash(bytes,(address,int256,address,uint256,uint256,address),(bytes,bytes)):(bytes32)",
      [
        ethereum.Value.fromBytes(param0),
        ethereum.Value.fromTuple(_externalData),
        ethereum.Value.fromTuple(_encryptions)
      ]
    );

    return result[0].toBytes();
  }

  try__genExtDataHash(
    param0: Bytes,
    _externalData: VAnchorHermes___genExtDataHashInput_externalDataStruct,
    _encryptions: VAnchorHermes___genExtDataHashInput_encryptionsStruct
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "_genExtDataHash",
      "_genExtDataHash(bytes,(address,int256,address,uint256,uint256,address),(bytes,bytes)):(bytes32)",
      [
        ethereum.Value.fromBytes(param0),
        ethereum.Value.fromTuple(_externalData),
        ethereum.Value.fromTuple(_encryptions)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  calculatePublicAmount(_extAmount: BigInt, _fee: BigInt): BigInt {
    let result = super.call(
      "calculatePublicAmount",
      "calculatePublicAmount(int256,uint256):(uint256)",
      [
        ethereum.Value.fromSignedBigInt(_extAmount),
        ethereum.Value.fromUnsignedBigInt(_fee)
      ]
    );

    return result[0].toBigInt();
  }

  try_calculatePublicAmount(
    _extAmount: BigInt,
    _fee: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "calculatePublicAmount",
      "calculatePublicAmount(int256,uint256):(uint256)",
      [
        ethereum.Value.fromSignedBigInt(_extAmount),
        ethereum.Value.fromUnsignedBigInt(_fee)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  commitments(param0: BigInt): boolean {
    let result = super.call("commitments", "commitments(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toBoolean();
  }

  try_commitments(param0: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("commitments", "commitments(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  currentNeighborRootIndex(param0: BigInt): BigInt {
    let result = super.call(
      "currentNeighborRootIndex",
      "currentNeighborRootIndex(uint256):(uint32)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toBigInt();
  }

  try_currentNeighborRootIndex(param0: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "currentNeighborRootIndex",
      "currentNeighborRootIndex(uint256):(uint32)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  edgeExistsForChain(param0: BigInt): boolean {
    let result = super.call(
      "edgeExistsForChain",
      "edgeExistsForChain(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toBoolean();
  }

  try_edgeExistsForChain(param0: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "edgeExistsForChain",
      "edgeExistsForChain(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  edgeIndex(param0: BigInt): BigInt {
    let result = super.call("edgeIndex", "edgeIndex(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toBigInt();
  }

  try_edgeIndex(param0: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall("edgeIndex", "edgeIndex(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  edgeList(param0: BigInt): VAnchorHermes__edgeListResult {
    let result = super.call(
      "edgeList",
      "edgeList(uint256):(uint256,uint256,uint256,bytes32)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return new VAnchorHermes__edgeListResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBytes()
    );
  }

  try_edgeList(
    param0: BigInt
  ): ethereum.CallResult<VAnchorHermes__edgeListResult> {
    let result = super.tryCall(
      "edgeList",
      "edgeList(uint256):(uint256,uint256,uint256,bytes32)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new VAnchorHermes__edgeListResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBytes()
      )
    );
  }

  filledSubtrees(param0: BigInt): BigInt {
    let result = super.call(
      "filledSubtrees",
      "filledSubtrees(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toBigInt();
  }

  try_filledSubtrees(param0: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "filledSubtrees",
      "filledSubtrees(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getChainId(): BigInt {
    let result = super.call("getChainId", "getChainId():(uint256)", []);

    return result[0].toBigInt();
  }

  try_getChainId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getChainId", "getChainId():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getChainIdType(): BigInt {
    let result = super.call("getChainIdType", "getChainIdType():(uint48)", []);

    return result[0].toBigInt();
  }

  try_getChainIdType(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getChainIdType",
      "getChainIdType():(uint48)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getHasher(): Address {
    let result = super.call("getHasher", "getHasher():(address)", []);

    return result[0].toAddress();
  }

  try_getHasher(): ethereum.CallResult<Address> {
    let result = super.tryCall("getHasher", "getHasher():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getLastRoot(): BigInt {
    let result = super.call("getLastRoot", "getLastRoot():(uint256)", []);

    return result[0].toBigInt();
  }

  try_getLastRoot(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getLastRoot", "getLastRoot():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getLatestNeighborEdges(): Array<
    VAnchorHermes__getLatestNeighborEdgesResultValue0Struct
  > {
    let result = super.call(
      "getLatestNeighborEdges",
      "getLatestNeighborEdges():((uint256,uint256,uint256,bytes32)[])",
      []
    );

    return result[0].toTupleArray<
      VAnchorHermes__getLatestNeighborEdgesResultValue0Struct
    >();
  }

  try_getLatestNeighborEdges(): ethereum.CallResult<
    Array<VAnchorHermes__getLatestNeighborEdgesResultValue0Struct>
  > {
    let result = super.tryCall(
      "getLatestNeighborEdges",
      "getLatestNeighborEdges():((uint256,uint256,uint256,bytes32)[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<
        VAnchorHermes__getLatestNeighborEdgesResultValue0Struct
      >()
    );
  }

  getLatestNeighborRoots(): Array<BigInt> {
    let result = super.call(
      "getLatestNeighborRoots",
      "getLatestNeighborRoots():(uint256[])",
      []
    );

    return result[0].toBigIntArray();
  }

  try_getLatestNeighborRoots(): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "getLatestNeighborRoots",
      "getLatestNeighborRoots():(uint256[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  getLevels(): BigInt {
    let result = super.call("getLevels", "getLevels():(uint32)", []);

    return result[0].toBigInt();
  }

  try_getLevels(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getLevels", "getLevels():(uint32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getNextIndex(): BigInt {
    let result = super.call("getNextIndex", "getNextIndex():(uint32)", []);

    return result[0].toBigInt();
  }

  try_getNextIndex(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getNextIndex", "getNextIndex():(uint32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getProposalNonce(): BigInt {
    let result = super.call(
      "getProposalNonce",
      "getProposalNonce():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getProposalNonce(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getProposalNonce",
      "getProposalNonce():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getZeroHash(index: BigInt): BigInt {
    let result = super.call("getZeroHash", "getZeroHash(uint32):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(index)
    ]);

    return result[0].toBigInt();
  }

  try_getZeroHash(index: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getZeroHash", "getZeroHash(uint32):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(index)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  handler(): Address {
    let result = super.call("handler", "handler():(address)", []);

    return result[0].toAddress();
  }

  try_handler(): ethereum.CallResult<Address> {
    let result = super.tryCall("handler", "handler():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  hasEdge(_chainID: BigInt): boolean {
    let result = super.call("hasEdge", "hasEdge(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(_chainID)
    ]);

    return result[0].toBoolean();
  }

  try_hasEdge(_chainID: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("hasEdge", "hasEdge(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(_chainID)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  hashLeftRight(_left: BigInt, _right: BigInt): BigInt {
    let result = super.call(
      "hashLeftRight",
      "hashLeftRight(uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_left),
        ethereum.Value.fromUnsignedBigInt(_right)
      ]
    );

    return result[0].toBigInt();
  }

  try_hashLeftRight(
    _left: BigInt,
    _right: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "hashLeftRight",
      "hashLeftRight(uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_left),
        ethereum.Value.fromUnsignedBigInt(_right)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  initialized(): boolean {
    let result = super.call("initialized", "initialized():(bool)", []);

    return result[0].toBoolean();
  }

  try_initialized(): ethereum.CallResult<boolean> {
    let result = super.tryCall("initialized", "initialized():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isCorrectExecutionChain(resourceID: Bytes): boolean {
    let result = super.call(
      "isCorrectExecutionChain",
      "isCorrectExecutionChain(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(resourceID)]
    );

    return result[0].toBoolean();
  }

  try_isCorrectExecutionChain(resourceID: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isCorrectExecutionChain",
      "isCorrectExecutionChain(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(resourceID)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isCorrectExecutionContext(resourceId: Bytes): boolean {
    let result = super.call(
      "isCorrectExecutionContext",
      "isCorrectExecutionContext(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(resourceId)]
    );

    return result[0].toBoolean();
  }

  try_isCorrectExecutionContext(
    resourceId: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isCorrectExecutionContext",
      "isCorrectExecutionContext(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(resourceId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isKnownNeighborRoot(_neighborChainID: BigInt, _root: BigInt): boolean {
    let result = super.call(
      "isKnownNeighborRoot",
      "isKnownNeighborRoot(uint256,uint256):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(_neighborChainID),
        ethereum.Value.fromUnsignedBigInt(_root)
      ]
    );

    return result[0].toBoolean();
  }

  try_isKnownNeighborRoot(
    _neighborChainID: BigInt,
    _root: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isKnownNeighborRoot",
      "isKnownNeighborRoot(uint256,uint256):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(_neighborChainID),
        ethereum.Value.fromUnsignedBigInt(_root)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isKnownRoot(root: BigInt): boolean {
    let result = super.call("isKnownRoot", "isKnownRoot(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(root)
    ]);

    return result[0].toBoolean();
  }

  try_isKnownRoot(root: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("isKnownRoot", "isKnownRoot(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(root)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isSpent(_nullifierHash: BigInt): boolean {
    let result = super.call("isSpent", "isSpent(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(_nullifierHash)
    ]);

    return result[0].toBoolean();
  }

  try_isSpent(_nullifierHash: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("isSpent", "isSpent(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(_nullifierHash)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isSpentArray(_nullifierHashes: Array<BigInt>): Array<boolean> {
    let result = super.call(
      "isSpentArray",
      "isSpentArray(uint256[]):(bool[])",
      [ethereum.Value.fromUnsignedBigIntArray(_nullifierHashes)]
    );

    return result[0].toBooleanArray();
  }

  try_isSpentArray(
    _nullifierHashes: Array<BigInt>
  ): ethereum.CallResult<Array<boolean>> {
    let result = super.tryCall(
      "isSpentArray",
      "isSpentArray(uint256[]):(bool[])",
      [ethereum.Value.fromUnsignedBigIntArray(_nullifierHashes)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBooleanArray());
  }

  isValidRoots(_roots: Array<BigInt>): boolean {
    let result = super.call("isValidRoots", "isValidRoots(uint256[]):(bool)", [
      ethereum.Value.fromUnsignedBigIntArray(_roots)
    ]);

    return result[0].toBoolean();
  }

  try_isValidRoots(_roots: Array<BigInt>): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isValidRoots",
      "isValidRoots(uint256[]):(bool)",
      [ethereum.Value.fromUnsignedBigIntArray(_roots)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  lastBalance(): BigInt {
    let result = super.call("lastBalance", "lastBalance():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lastBalance(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("lastBalance", "lastBalance():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maxEdges(): i32 {
    let result = super.call("maxEdges", "maxEdges():(uint8)", []);

    return result[0].toI32();
  }

  try_maxEdges(): ethereum.CallResult<i32> {
    let result = super.tryCall("maxEdges", "maxEdges():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  maximumDepositAmount(): BigInt {
    let result = super.call(
      "maximumDepositAmount",
      "maximumDepositAmount():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_maximumDepositAmount(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "maximumDepositAmount",
      "maximumDepositAmount():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minimalWithdrawalAmount(): BigInt {
    let result = super.call(
      "minimalWithdrawalAmount",
      "minimalWithdrawalAmount():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_minimalWithdrawalAmount(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minimalWithdrawalAmount",
      "minimalWithdrawalAmount():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  neighborRoots(param0: BigInt, param1: BigInt): BigInt {
    let result = super.call(
      "neighborRoots",
      "neighborRoots(uint256,uint32):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return result[0].toBigInt();
  }

  try_neighborRoots(
    param0: BigInt,
    param1: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "neighborRoots",
      "neighborRoots(uint256,uint32):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  nullifierHashes(param0: BigInt): boolean {
    let result = super.call(
      "nullifierHashes",
      "nullifierHashes(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toBoolean();
  }

  try_nullifierHashes(param0: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "nullifierHashes",
      "nullifierHashes(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  outerLevels(): BigInt {
    let result = super.call("outerLevels", "outerLevels():(uint32)", []);

    return result[0].toBigInt();
  }

  try_outerLevels(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("outerLevels", "outerLevels():(uint32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  parseChainIdFromResourceId(_resourceId: Bytes): BigInt {
    let result = super.call(
      "parseChainIdFromResourceId",
      "parseChainIdFromResourceId(bytes32):(uint64)",
      [ethereum.Value.fromFixedBytes(_resourceId)]
    );

    return result[0].toBigInt();
  }

  try_parseChainIdFromResourceId(
    _resourceId: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "parseChainIdFromResourceId",
      "parseChainIdFromResourceId(bytes32):(uint64)",
      [ethereum.Value.fromFixedBytes(_resourceId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  proposalNonce(): BigInt {
    let result = super.call("proposalNonce", "proposalNonce():(uint256)", []);

    return result[0].toBigInt();
  }

  try_proposalNonce(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "proposalNonce",
      "proposalNonce():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  roots(param0: BigInt): VAnchorHermes__rootsResult {
    let result = super.call("roots", "roots(uint256):(uint256,uint32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return new VAnchorHermes__rootsResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_roots(param0: BigInt): ethereum.CallResult<VAnchorHermes__rootsResult> {
    let result = super.tryCall("roots", "roots(uint256):(uint256,uint32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new VAnchorHermes__rootsResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  token(): Address {
    let result = super.call("token", "token():(address)", []);

    return result[0].toAddress();
  }

  try_token(): ethereum.CallResult<Address> {
    let result = super.tryCall("token", "token():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  unpackProof(_proof: Array<BigInt>): VAnchorHermes__unpackProofResult {
    let result = super.call(
      "unpackProof",
      "unpackProof(uint256[8]):(uint256[2],uint256[2][2],uint256[2])",
      [ethereum.Value.fromUnsignedBigIntArray(_proof)]
    );

    return new VAnchorHermes__unpackProofResult(
      result[0].toBigIntArray(),
      result[1].toBigIntMatrix(),
      result[2].toBigIntArray()
    );
  }

  try_unpackProof(
    _proof: Array<BigInt>
  ): ethereum.CallResult<VAnchorHermes__unpackProofResult> {
    let result = super.tryCall(
      "unpackProof",
      "unpackProof(uint256[8]):(uint256[2],uint256[2][2],uint256[2])",
      [ethereum.Value.fromUnsignedBigIntArray(_proof)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new VAnchorHermes__unpackProofResult(
        value[0].toBigIntArray(),
        value[1].toBigIntMatrix(),
        value[2].toBigIntArray()
      )
    );
  }

  verifier(): Address {
    let result = super.call("verifier", "verifier():(address)", []);

    return result[0].toAddress();
  }

  try_verifier(): ethereum.CallResult<Address> {
    let result = super.tryCall("verifier", "verifier():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class _executeWrappingCall extends ethereum.Call {
  get inputs(): _executeWrappingCall__Inputs {
    return new _executeWrappingCall__Inputs(this);
  }

  get outputs(): _executeWrappingCall__Outputs {
    return new _executeWrappingCall__Outputs(this);
  }
}

export class _executeWrappingCall__Inputs {
  _call: _executeWrappingCall;

  constructor(call: _executeWrappingCall) {
    this._call = call;
  }

  get _fromTokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _toTokenAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _extAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class _executeWrappingCall__Outputs {
  _call: _executeWrappingCall;

  constructor(call: _executeWrappingCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class _genExtDataHashCall extends ethereum.Call {
  get inputs(): _genExtDataHashCall__Inputs {
    return new _genExtDataHashCall__Inputs(this);
  }

  get outputs(): _genExtDataHashCall__Outputs {
    return new _genExtDataHashCall__Outputs(this);
  }
}

export class _genExtDataHashCall__Inputs {
  _call: _genExtDataHashCall;

  constructor(call: _genExtDataHashCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _externalData(): _genExtDataHashCall_externalDataStruct {
    return changetype<_genExtDataHashCall_externalDataStruct>(
      this._call.inputValues[1].value.toTuple()
    );
  }

  get _encryptions(): _genExtDataHashCall_encryptionsStruct {
    return changetype<_genExtDataHashCall_encryptionsStruct>(
      this._call.inputValues[2].value.toTuple()
    );
  }
}

export class _genExtDataHashCall__Outputs {
  _call: _genExtDataHashCall;

  constructor(call: _genExtDataHashCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class _genExtDataHashCall_externalDataStruct extends ethereum.Tuple {
  get recipient(): Address {
    return this[0].toAddress();
  }

  get extAmount(): BigInt {
    return this[1].toBigInt();
  }

  get relayer(): Address {
    return this[2].toAddress();
  }

  get fee(): BigInt {
    return this[3].toBigInt();
  }

  get refund(): BigInt {
    return this[4].toBigInt();
  }

  get token(): Address {
    return this[5].toAddress();
  }
}

export class _genExtDataHashCall_encryptionsStruct extends ethereum.Tuple {
  get encryptedOutput1(): Bytes {
    return this[0].toBytes();
  }

  get encryptedOutput2(): Bytes {
    return this[1].toBytes();
  }
}

export class _withdrawAndUnwrapCall extends ethereum.Call {
  get inputs(): _withdrawAndUnwrapCall__Inputs {
    return new _withdrawAndUnwrapCall__Inputs(this);
  }

  get outputs(): _withdrawAndUnwrapCall__Outputs {
    return new _withdrawAndUnwrapCall__Outputs(this);
  }
}

export class _withdrawAndUnwrapCall__Inputs {
  _call: _withdrawAndUnwrapCall;

  constructor(call: _withdrawAndUnwrapCall) {
    this._call = call;
  }

  get _fromTokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _toTokenAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _recipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _minusExtAmount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class _withdrawAndUnwrapCall__Outputs {
  _call: _withdrawAndUnwrapCall;

  constructor(call: _withdrawAndUnwrapCall) {
    this._call = call;
  }
}

export class ConfigureMaximumDepositLimitCall extends ethereum.Call {
  get inputs(): ConfigureMaximumDepositLimitCall__Inputs {
    return new ConfigureMaximumDepositLimitCall__Inputs(this);
  }

  get outputs(): ConfigureMaximumDepositLimitCall__Outputs {
    return new ConfigureMaximumDepositLimitCall__Outputs(this);
  }
}

export class ConfigureMaximumDepositLimitCall__Inputs {
  _call: ConfigureMaximumDepositLimitCall;

  constructor(call: ConfigureMaximumDepositLimitCall) {
    this._call = call;
  }

  get _maximumDepositAmount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _nonce(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ConfigureMaximumDepositLimitCall__Outputs {
  _call: ConfigureMaximumDepositLimitCall;

  constructor(call: ConfigureMaximumDepositLimitCall) {
    this._call = call;
  }
}

export class ConfigureMinimalWithdrawalLimitCall extends ethereum.Call {
  get inputs(): ConfigureMinimalWithdrawalLimitCall__Inputs {
    return new ConfigureMinimalWithdrawalLimitCall__Inputs(this);
  }

  get outputs(): ConfigureMinimalWithdrawalLimitCall__Outputs {
    return new ConfigureMinimalWithdrawalLimitCall__Outputs(this);
  }
}

export class ConfigureMinimalWithdrawalLimitCall__Inputs {
  _call: ConfigureMinimalWithdrawalLimitCall;

  constructor(call: ConfigureMinimalWithdrawalLimitCall) {
    this._call = call;
  }

  get _minimalWithdrawalAmount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _nonce(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ConfigureMinimalWithdrawalLimitCall__Outputs {
  _call: ConfigureMinimalWithdrawalLimitCall;

  constructor(call: ConfigureMinimalWithdrawalLimitCall) {
    this._call = call;
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get _minimalWithdrawalAmount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _maximumDepositAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class RegisterCall extends ethereum.Call {
  get inputs(): RegisterCall__Inputs {
    return new RegisterCall__Inputs(this);
  }

  get outputs(): RegisterCall__Outputs {
    return new RegisterCall__Outputs(this);
  }
}

export class RegisterCall__Inputs {
  _call: RegisterCall;

  constructor(call: RegisterCall) {
    this._call = call;
  }

  get _account(): RegisterCall_accountStruct {
    return changetype<RegisterCall_accountStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }
}

export class RegisterCall__Outputs {
  _call: RegisterCall;

  constructor(call: RegisterCall) {
    this._call = call;
  }
}

export class RegisterCall_accountStruct extends ethereum.Tuple {
  get owner(): Address {
    return this[0].toAddress();
  }

  get keyData(): Bytes {
    return this[1].toBytes();
  }
}

export class RegisterAndTransactCall extends ethereum.Call {
  get inputs(): RegisterAndTransactCall__Inputs {
    return new RegisterAndTransactCall__Inputs(this);
  }

  get outputs(): RegisterAndTransactCall__Outputs {
    return new RegisterAndTransactCall__Outputs(this);
  }
}

export class RegisterAndTransactCall__Inputs {
  _call: RegisterAndTransactCall;

  constructor(call: RegisterAndTransactCall) {
    this._call = call;
  }

  get _account(): RegisterAndTransactCall_accountStruct {
    return changetype<RegisterAndTransactCall_accountStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get _proof(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get _auxPublicInputs(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get _externalData(): RegisterAndTransactCall_externalDataStruct {
    return changetype<RegisterAndTransactCall_externalDataStruct>(
      this._call.inputValues[3].value.toTuple()
    );
  }

  get _publicInputs(): RegisterAndTransactCall_publicInputsStruct {
    return changetype<RegisterAndTransactCall_publicInputsStruct>(
      this._call.inputValues[4].value.toTuple()
    );
  }

  get _encryptions(): RegisterAndTransactCall_encryptionsStruct {
    return changetype<RegisterAndTransactCall_encryptionsStruct>(
      this._call.inputValues[5].value.toTuple()
    );
  }
}

export class RegisterAndTransactCall__Outputs {
  _call: RegisterAndTransactCall;

  constructor(call: RegisterAndTransactCall) {
    this._call = call;
  }
}

export class RegisterAndTransactCall_accountStruct extends ethereum.Tuple {
  get owner(): Address {
    return this[0].toAddress();
  }

  get keyData(): Bytes {
    return this[1].toBytes();
  }
}

export class RegisterAndTransactCall_externalDataStruct extends ethereum.Tuple {
  get recipient(): Address {
    return this[0].toAddress();
  }

  get extAmount(): BigInt {
    return this[1].toBigInt();
  }

  get relayer(): Address {
    return this[2].toAddress();
  }

  get fee(): BigInt {
    return this[3].toBigInt();
  }

  get refund(): BigInt {
    return this[4].toBigInt();
  }

  get token(): Address {
    return this[5].toAddress();
  }
}

export class RegisterAndTransactCall_publicInputsStruct extends ethereum.Tuple {
  get roots(): Bytes {
    return this[0].toBytes();
  }

  get extensionRoots(): Bytes {
    return this[1].toBytes();
  }

  get inputNullifiers(): Array<BigInt> {
    return this[2].toBigIntArray();
  }

  get outputCommitments(): Array<BigInt> {
    return this[3].toBigIntArray();
  }

  get publicAmount(): BigInt {
    return this[4].toBigInt();
  }

  get extDataHash(): BigInt {
    return this[5].toBigInt();
  }
}

export class RegisterAndTransactCall_encryptionsStruct extends ethereum.Tuple {
  get encryptedOutput1(): Bytes {
    return this[0].toBytes();
  }

  get encryptedOutput2(): Bytes {
    return this[1].toBytes();
  }
}

export class SetHandlerCall extends ethereum.Call {
  get inputs(): SetHandlerCall__Inputs {
    return new SetHandlerCall__Inputs(this);
  }

  get outputs(): SetHandlerCall__Outputs {
    return new SetHandlerCall__Outputs(this);
  }
}

export class SetHandlerCall__Inputs {
  _call: SetHandlerCall;

  constructor(call: SetHandlerCall) {
    this._call = call;
  }

  get _handler(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _nonce(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetHandlerCall__Outputs {
  _call: SetHandlerCall;

  constructor(call: SetHandlerCall) {
    this._call = call;
  }
}

export class SetVerifierCall extends ethereum.Call {
  get inputs(): SetVerifierCall__Inputs {
    return new SetVerifierCall__Inputs(this);
  }

  get outputs(): SetVerifierCall__Outputs {
    return new SetVerifierCall__Outputs(this);
  }
}

export class SetVerifierCall__Inputs {
  _call: SetVerifierCall;

  constructor(call: SetVerifierCall) {
    this._call = call;
  }

  get _verifier(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _nonce(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetVerifierCall__Outputs {
  _call: SetVerifierCall;

  constructor(call: SetVerifierCall) {
    this._call = call;
  }
}

export class TransactCall extends ethereum.Call {
  get inputs(): TransactCall__Inputs {
    return new TransactCall__Inputs(this);
  }

  get outputs(): TransactCall__Outputs {
    return new TransactCall__Outputs(this);
  }
}

export class TransactCall__Inputs {
  _call: TransactCall;

  constructor(call: TransactCall) {
    this._call = call;
  }

  get _proof(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _auxPublicInputs(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get _externalData(): TransactCall_externalDataStruct {
    return changetype<TransactCall_externalDataStruct>(
      this._call.inputValues[2].value.toTuple()
    );
  }

  get _publicInputs(): TransactCall_publicInputsStruct {
    return changetype<TransactCall_publicInputsStruct>(
      this._call.inputValues[3].value.toTuple()
    );
  }

  get _encryptions(): TransactCall_encryptionsStruct {
    return changetype<TransactCall_encryptionsStruct>(
      this._call.inputValues[4].value.toTuple()
    );
  }
}

export class TransactCall__Outputs {
  _call: TransactCall;

  constructor(call: TransactCall) {
    this._call = call;
  }
}

export class TransactCall_externalDataStruct extends ethereum.Tuple {
  get recipient(): Address {
    return this[0].toAddress();
  }

  get extAmount(): BigInt {
    return this[1].toBigInt();
  }

  get relayer(): Address {
    return this[2].toAddress();
  }

  get fee(): BigInt {
    return this[3].toBigInt();
  }

  get refund(): BigInt {
    return this[4].toBigInt();
  }

  get token(): Address {
    return this[5].toAddress();
  }
}

export class TransactCall_publicInputsStruct extends ethereum.Tuple {
  get roots(): Bytes {
    return this[0].toBytes();
  }

  get extensionRoots(): Bytes {
    return this[1].toBytes();
  }

  get inputNullifiers(): Array<BigInt> {
    return this[2].toBigIntArray();
  }

  get outputCommitments(): Array<BigInt> {
    return this[3].toBigIntArray();
  }

  get publicAmount(): BigInt {
    return this[4].toBigInt();
  }

  get extDataHash(): BigInt {
    return this[5].toBigInt();
  }
}

export class TransactCall_encryptionsStruct extends ethereum.Tuple {
  get encryptedOutput1(): Bytes {
    return this[0].toBytes();
  }

  get encryptedOutput2(): Bytes {
    return this[1].toBytes();
  }
}

export class UpdateEdgeCall extends ethereum.Call {
  get inputs(): UpdateEdgeCall__Inputs {
    return new UpdateEdgeCall__Inputs(this);
  }

  get outputs(): UpdateEdgeCall__Outputs {
    return new UpdateEdgeCall__Outputs(this);
  }
}

export class UpdateEdgeCall__Inputs {
  _call: UpdateEdgeCall;

  constructor(call: UpdateEdgeCall) {
    this._call = call;
  }

  get _root(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _leafIndex(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _srcResourceID(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class UpdateEdgeCall__Outputs {
  _call: UpdateEdgeCall;

  constructor(call: UpdateEdgeCall) {
    this._call = call;
  }
}
